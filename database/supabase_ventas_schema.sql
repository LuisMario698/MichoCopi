-- Script SQL para crear las tablas de ventas en Supabase
-- Sistema MichoCopi - Módulo de Ventas
-- Fecha: 27 de mayo de 2025
-- Compatible con estructura existente (nombres con mayúsculas y comillas)

-- =============================================================================
-- 1. MODIFICAR TABLA "Ventas" EXISTENTE (Agregar columnas faltantes)
-- =============================================================================

-- Agregar columnas faltantes a la tabla "Ventas" existente
ALTER TABLE public."Ventas" 
ADD COLUMN IF NOT EXISTS cliente character varying(200) NULL,
ADD COLUMN IF NOT EXISTS total numeric(10,2) NOT NULL DEFAULT 0 CHECK (total >= 0),
ADD COLUMN IF NOT EXISTS fecha timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
ADD COLUMN IF NOT EXISTS estado character varying(20) DEFAULT 'Completada' NOT NULL 
    CHECK (estado IN ('Completada', 'Pendiente', 'Cancelada')),
ADD COLUMN IF NOT EXISTS usuario_id bigint NULL REFERENCES public."Usuarios"(id) ON DELETE SET NULL,
ADD COLUMN IF NOT EXISTS created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
ADD COLUMN IF NOT EXISTS updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL;

-- Índices para optimizar consultas
CREATE INDEX IF NOT EXISTS idx_ventas_fecha ON public."Ventas"(fecha DESC);
CREATE INDEX IF NOT EXISTS idx_ventas_cliente ON public."Ventas"(cliente);
CREATE INDEX IF NOT EXISTS idx_ventas_estado ON public."Ventas"(estado);
CREATE INDEX IF NOT EXISTS idx_ventas_usuario ON public."Ventas"(usuario_id);

-- =============================================================================
-- 2. CREAR TABLA "Venta_Detalles" (Líneas de la venta)
-- =============================================================================

CREATE TABLE IF NOT EXISTS public."Venta_Detalles" (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    venta_id bigint NOT NULL REFERENCES public."Ventas"(id) ON DELETE CASCADE,
    producto_id bigint NOT NULL REFERENCES public."Productos"(id) ON DELETE RESTRICT,
    nombre_producto character varying(200) NOT NULL, -- Copia del nombre al momento de la venta
    cantidad integer NOT NULL CHECK (cantidad > 0),
    precio_unitario numeric(10,2) NOT NULL CHECK (precio_unitario >= 0),
    subtotal numeric(10,2) NOT NULL CHECK (subtotal >= 0),
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL
);

-- Índices para optimizar consultas
CREATE INDEX IF NOT EXISTS idx_venta_detalles_venta ON public."Venta_Detalles"(venta_id);
CREATE INDEX IF NOT EXISTS idx_venta_detalles_producto ON public."Venta_Detalles"(producto_id);

-- =============================================================================
-- 3. TRIGGER PARA CALCULAR SUBTOTAL AUTOMÁTICAMENTE
-- =============================================================================

CREATE OR REPLACE FUNCTION public.calcular_subtotal()
RETURNS TRIGGER AS $$
BEGIN
    -- Calcular subtotal automáticamente
    NEW.subtotal = NEW.cantidad * NEW.precio_unitario;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Aplicar trigger antes de insertar o actualizar
CREATE TRIGGER trigger_calcular_subtotal
    BEFORE INSERT OR UPDATE ON public."Venta_Detalles"
    FOR EACH ROW
    EXECUTE FUNCTION public.calcular_subtotal();

-- =============================================================================
-- 4. TRIGGER PARA ACTUALIZAR TOTAL DE VENTA
-- =============================================================================

CREATE OR REPLACE FUNCTION public.actualizar_total_venta()
RETURNS TRIGGER AS $$
BEGIN    -- Actualizar el total de la venta cuando se modifiquen los detalles
    IF TG_OP = 'DELETE' THEN
        UPDATE public."Ventas" 
        SET total = COALESCE((
            SELECT SUM(subtotal) 
            FROM public."Venta_Detalles" 
            WHERE venta_id = OLD.venta_id
        ), 0)
        WHERE id = OLD.venta_id;
        RETURN OLD;
    ELSE
        UPDATE public."Ventas" 
        SET total = COALESCE((
            SELECT SUM(subtotal) 
            FROM public."Venta_Detalles" 
            WHERE venta_id = NEW.venta_id
        ), 0)
        WHERE id = NEW.venta_id;
        RETURN NEW;
    END IF;
END;
$$ LANGUAGE plpgsql;

-- Aplicar trigger después de modificar detalles
CREATE TRIGGER trigger_actualizar_total_venta
    AFTER INSERT OR UPDATE OR DELETE ON public."Venta_Detalles"
    FOR EACH ROW
    EXECUTE FUNCTION public.actualizar_total_venta();

-- =============================================================================
-- 5. TRIGGER PARA UPDATED_AT EN VENTAS
-- =============================================================================

CREATE TRIGGER update_ventas_updated_at
    BEFORE UPDATE ON public."Ventas"
    FOR EACH ROW
    EXECUTE FUNCTION public.handle_updated_at();

-- =============================================================================
-- 6. FUNCIÓN PARA OBTENER VENTAS CON FILTROS
-- =============================================================================

CREATE OR REPLACE FUNCTION public.obtener_ventas_filtradas(
    p_limite INTEGER DEFAULT 50,
    p_offset INTEGER DEFAULT 0,
    p_filtro_fecha TEXT DEFAULT NULL,
    p_cliente TEXT DEFAULT NULL
)
RETURNS TABLE (
    id BIGINT,
    cliente VARCHAR(200),
    total DECIMAL(10,2),
    fecha TIMESTAMP WITH TIME ZONE,
    estado VARCHAR(20),
    cantidad_items BIGINT
) AS $$
DECLARE
    fecha_inicio TIMESTAMP WITH TIME ZONE;
    fecha_fin TIMESTAMP WITH TIME ZONE;
BEGIN
    -- Calcular fechas según el filtro
    IF p_filtro_fecha IS NOT NULL THEN
        CASE p_filtro_fecha
            WHEN 'Hoy' THEN
                fecha_inicio := DATE_TRUNC('day', NOW());
                fecha_fin := fecha_inicio + INTERVAL '1 day';
            WHEN 'Esta semana' THEN
                fecha_inicio := DATE_TRUNC('week', NOW());
                fecha_fin := fecha_inicio + INTERVAL '1 week';
            WHEN 'Este mes' THEN
                fecha_inicio := DATE_TRUNC('month', NOW());
                fecha_fin := fecha_inicio + INTERVAL '1 month';
            ELSE
                fecha_inicio := NULL;
                fecha_fin := NULL;
        END CASE;
    END IF;    RETURN QUERY
    SELECT 
        v.id,
        v.cliente,
        v.total,
        v.fecha,
        v.estado,
        COALESCE(COUNT(vd.id), 0) as cantidad_items
    FROM public."Ventas" v
    LEFT JOIN public."Venta_Detalles" vd ON v.id = vd.venta_id
    WHERE 
        (fecha_inicio IS NULL OR v.fecha >= fecha_inicio)
        AND (fecha_fin IS NULL OR v.fecha < fecha_fin)
        AND (p_cliente IS NULL OR v.cliente ILIKE '%' || p_cliente || '%')
    GROUP BY v.id, v.cliente, v.total, v.fecha, v.estado
    ORDER BY v.fecha DESC
    LIMIT p_limite
    OFFSET p_offset;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================================================
-- 7. FUNCIÓN PARA ESTADÍSTICAS DE VENTAS
-- =============================================================================

CREATE OR REPLACE FUNCTION public.obtener_estadisticas_ventas(
    p_periodo TEXT DEFAULT 'mes'
)
RETURNS JSON AS $$
DECLARE
    fecha_inicio TIMESTAMP WITH TIME ZONE;
    total_ventas INTEGER;
    monto_total DECIMAL(10,2);
    promedio_venta DECIMAL(10,2);
    resultado JSON;
BEGIN
    -- Calcular fecha de inicio según período
    CASE p_periodo
        WHEN 'dia' THEN
            fecha_inicio := DATE_TRUNC('day', NOW());
        WHEN 'semana' THEN
            fecha_inicio := DATE_TRUNC('week', NOW());
        WHEN 'mes' THEN
            fecha_inicio := DATE_TRUNC('month', NOW());
        WHEN 'año' THEN
            fecha_inicio := DATE_TRUNC('year', NOW());
        ELSE
            fecha_inicio := DATE_TRUNC('month', NOW());
    END CASE;

    -- Calcular estadísticas
    SELECT 
        COUNT(*),
        COALESCE(SUM(total), 0),
        COALESCE(AVG(total), 0)
    INTO total_ventas, monto_total, promedio_venta    FROM public."Ventas"
    WHERE fecha >= fecha_inicio AND estado = 'Completada';

    -- Construir resultado JSON
    resultado := json_build_object(
        'total_ventas', total_ventas,
        'monto_total', monto_total,
        'promedio_venta', promedio_venta,
        'periodo', p_periodo,
        'fecha_inicio', fecha_inicio
    );

    RETURN resultado;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================================================
-- 8. POLÍTICAS DE SEGURIDAD RLS
-- =============================================================================

-- Habilitar RLS
ALTER TABLE public."Ventas" ENABLE ROW LEVEL SECURITY;
ALTER TABLE public."Venta_Detalles" ENABLE ROW LEVEL SECURITY;

-- Política para ventas: todos los usuarios autenticados pueden ver y crear
CREATE POLICY "Allow authenticated users to manage ventas" ON public."Ventas"
    FOR ALL
    USING (true)
    WITH CHECK (true);

-- Política para detalles: todos los usuarios autenticados pueden ver y crear
CREATE POLICY "Allow authenticated users to manage venta_detalles" ON public."Venta_Detalles"
    FOR ALL
    USING (true)
    WITH CHECK (true);

-- =============================================================================
-- 9. VISTAS ÚTILES
-- =============================================================================

-- Vista para ventas con resumen
CREATE OR REPLACE VIEW public."Ventas_Resumen" AS
SELECT 
    v.id,
    v.cliente,
    v.total,
    v.fecha,
    v.estado,
    COUNT(vd.id) as cantidad_items,
    STRING_AGG(vd.nombre_producto, ', ') as productos
FROM public."Ventas" v
LEFT JOIN public."Venta_Detalles" vd ON v.id = vd.venta_id
GROUP BY v.id, v.cliente, v.total, v.fecha, v.estado
ORDER BY v.fecha DESC;

-- Vista para productos más vendidos
CREATE OR REPLACE VIEW public."Productos_Mas_Vendidos" AS
SELECT 
    vd.producto_id,
    vd.nombre_producto,
    SUM(vd.cantidad) as total_vendido,
    COUNT(DISTINCT vd.venta_id) as numero_ventas,
    SUM(vd.subtotal) as ingresos_generados
FROM public."Venta_Detalles" vd
JOIN public."Ventas" v ON vd.venta_id = v.id
WHERE v.estado = 'Completada'
GROUP BY vd.producto_id, vd.nombre_producto
ORDER BY total_vendido DESC;

-- =============================================================================
-- 10. COMENTARIOS Y DOCUMENTACIÓN
-- =============================================================================

COMMENT ON TABLE public."Ventas" IS 'Encabezado de las ventas realizadas';
COMMENT ON TABLE public."Venta_Detalles" IS 'Detalle de productos vendidos en cada venta';

COMMENT ON COLUMN public."Ventas".cliente IS 'Nombre del cliente (opcional)';
COMMENT ON COLUMN public."Ventas".total IS 'Total de la venta calculado automáticamente';
COMMENT ON COLUMN public."Ventas".estado IS 'Estado: Completada, Pendiente, Cancelada';
COMMENT ON COLUMN public."Ventas".usuario_id IS 'Usuario que registró la venta';

COMMENT ON COLUMN public."Venta_Detalles".nombre_producto IS 'Nombre del producto al momento de la venta';
COMMENT ON COLUMN public."Venta_Detalles".subtotal IS 'Calculado automáticamente: cantidad * precio_unitario';

-- =============================================================================
-- 11. DATOS DE PRUEBA (OPCIONAL)
-- =============================================================================

-- Insertar algunas ventas de prueba
-- INSERT INTO public."Ventas" (cliente, estado) VALUES
--     ('Juan Pérez', 'Completada'),
--     ('María García', 'Completada'),
--     ('Cliente Anónimo', 'Completada');

-- =============================================================================
-- VERIFICACIÓN Y CONSULTAS DE PRUEBA
-- =============================================================================

-- Verificar que las tablas se crearon correctamente
SELECT 'Ventas' as tabla, count(*) as registros FROM public."Ventas"
UNION ALL
SELECT 'Venta_Detalles' as tabla, count(*) as registros FROM public."Venta_Detalles";

-- Mostrar estructura de las tablas
-- \d public."Ventas"
-- \d public."Venta_Detalles"

-- Consultas de prueba
-- SELECT * FROM public."Ventas_Resumen" LIMIT 10;
-- SELECT * FROM public."Productos_Mas_Vendidos" LIMIT 10;
-- SELECT public.obtener_estadisticas_ventas('mes');
