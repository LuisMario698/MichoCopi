-- ===================================================================
-- SISTEMA DE REPORTES COMPLETO - MÍNIMAS TABLAS ADICIONALES
-- ===================================================================
-- Fecha: 2024
-- Propósito: Sistema completo de reportes con mínimas tablas adicionales
-- Tablas base existentes: Ventas, Productos, Compras, Materia_prima, etc.

-- ===================================================================
-- 1. TABLA DE DETALLES DE VENTA (ESENCIAL)
-- ===================================================================
-- Esta tabla es CRÍTICA porque la tabla "Ventas" actual solo tiene:
-- - id_Productos[] (array) sin cantidades
-- - total general
-- Necesitamos saber QUÉ productos, CUÁNTOS y a QUÉ PRECIO se vendieron

CREATE TABLE public."Ventas_detalle" (
  id bigint generated by default as identity not null,
  id_venta bigint not null,
  id_producto bigint not null,
  cantidad integer not null,
  precio_unitario double precision not null,
  subtotal double precision not null,
  constraint Ventas_detalle_pkey primary key (id),
  constraint Ventas_detalle_id_venta_fkey foreign key (id_venta) references "Ventas" (id) ON DELETE CASCADE,
  constraint Ventas_detalle_id_producto_fkey foreign key (id_producto) references "Productos" (id)
);

-- Índices para optimizar consultas de reportes
CREATE INDEX idx_ventas_detalle_venta ON public."Ventas_detalle" (id_venta);
CREATE INDEX idx_ventas_detalle_producto ON public."Ventas_detalle" (id_producto);

-- ===================================================================
-- 2. TABLA DE RESÚMENES DIARIOS (OPCIONAL - PARA PERFORMANCE)
-- ===================================================================
-- Tabla para cachear reportes diarios y acelerar consultas

CREATE TABLE public."Reportes_diarios" (
  id bigint generated by default as identity not null,
  fecha date not null,
  total_ventas double precision not null default 0,
  numero_ventas integer not null default 0,
  total_compras double precision not null default 0,
  numero_compras integer not null default 0,
  productos_vendidos integer not null default 0,
  ticket_promedio double precision not null default 0,
  fecha_actualizacion timestamp without time zone not null default now(),
  constraint Reportes_diarios_pkey primary key (id),
  constraint Reportes_diarios_fecha_unique unique (fecha)
);

CREATE INDEX idx_reportes_diarios_fecha ON public."Reportes_diarios" (fecha);

-- ===================================================================
-- 3. TABLA DE COMPRAS_DETALLE (SI SE NECESITAN REPORTES DE COMPRAS DETALLADOS)
-- ===================================================================
-- Similar a Ventas_detalle pero para compras
-- Solo crear si necesitas reportes detallados de compras por producto

CREATE TABLE public."Compras_detalle" (
  id bigint generated by default as identity not null,
  id_compra bigint not null,
  id_materia_prima bigint not null,
  cantidad double precision not null,
  precio_unitario double precision not null,
  subtotal double precision not null,
  constraint Compras_detalle_pkey primary key (id),
  constraint Compras_detalle_id_compra_fkey foreign key (id_compra) references "Compras" (id) ON DELETE CASCADE,
  constraint Compras_detalle_id_mp_fkey foreign key (id_materia_prima) references "Materia_prima" (id)
);

CREATE INDEX idx_compras_detalle_compra ON public."Compras_detalle" (id_compra);
CREATE INDEX idx_compras_detalle_mp ON public."Compras_detalle" (id_materia_prima);

-- ===================================================================
-- 4. FUNCIONES PARA ACTUALIZAR REPORTES DIARIOS AUTOMÁTICAMENTE
-- ===================================================================

-- Función para calcular y actualizar resumen diario
CREATE OR REPLACE FUNCTION actualizar_reporte_diario(fecha_param date)
RETURNS void AS $$
DECLARE
    total_ventas_dia double precision := 0;
    num_ventas_dia integer := 0;
    total_compras_dia double precision := 0;
    num_compras_dia integer := 0;
    productos_vendidos_dia integer := 0;
    ticket_promedio_dia double precision := 0;
BEGIN
    -- Calcular ventas del día
    SELECT 
        COALESCE(SUM(total), 0),
        COUNT(*),
        COALESCE(AVG(total), 0)
    INTO total_ventas_dia, num_ventas_dia, ticket_promedio_dia
    FROM "Ventas" 
    WHERE DATE(fecha) = fecha_param;
    
    -- Calcular compras del día
    SELECT 
        COALESCE(SUM(total), 0),
        COUNT(*)
    INTO total_compras_dia, num_compras_dia
    FROM "Compras" 
    WHERE DATE(fecha) = fecha_param;
    
    -- Calcular productos vendidos (suma de cantidades)
    SELECT COALESCE(SUM(cantidad), 0)
    INTO productos_vendidos_dia
    FROM "Ventas_detalle" vd
    INNER JOIN "Ventas" v ON vd.id_venta = v.id
    WHERE DATE(v.fecha) = fecha_param;
    
    -- Insertar o actualizar el resumen diario
    INSERT INTO "Reportes_diarios" (
        fecha, total_ventas, numero_ventas, total_compras, 
        numero_compras, productos_vendidos, ticket_promedio
    ) VALUES (
        fecha_param, total_ventas_dia, num_ventas_dia, total_compras_dia,
        num_compras_dia, productos_vendidos_dia, ticket_promedio_dia
    )
    ON CONFLICT (fecha) DO UPDATE SET
        total_ventas = EXCLUDED.total_ventas,
        numero_ventas = EXCLUDED.numero_ventas,
        total_compras = EXCLUDED.total_compras,
        numero_compras = EXCLUDED.numero_compras,
        productos_vendidos = EXCLUDED.productos_vendidos,
        ticket_promedio = EXCLUDED.ticket_promedio,
        fecha_actualizacion = now();
END;
$$ LANGUAGE plpgsql;

-- ===================================================================
-- 5. TRIGGERS PARA ACTUALIZACIÓN AUTOMÁTICA
-- ===================================================================

-- Trigger para actualizar reportes cuando se inserta/actualiza una venta
CREATE OR REPLACE FUNCTION trigger_actualizar_reporte_venta()
RETURNS TRIGGER AS $$
BEGIN
    -- Actualizar reporte del día de la venta
    PERFORM actualizar_reporte_diario(DATE(NEW.fecha));
    
    -- Si es un UPDATE y cambió la fecha, actualizar también el día anterior
    IF TG_OP = 'UPDATE' AND DATE(OLD.fecha) != DATE(NEW.fecha) THEN
        PERFORM actualizar_reporte_diario(DATE(OLD.fecha));
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_ventas_reporte
    AFTER INSERT OR UPDATE ON "Ventas"
    FOR EACH ROW
    EXECUTE FUNCTION trigger_actualizar_reporte_venta();

-- Trigger para actualizar reportes cuando se inserta/actualiza una compra
CREATE OR REPLACE FUNCTION trigger_actualizar_reporte_compra()
RETURNS TRIGGER AS $$
BEGIN
    PERFORM actualizar_reporte_diario(DATE(NEW.fecha));
    
    IF TG_OP = 'UPDATE' AND DATE(OLD.fecha) != DATE(NEW.fecha) THEN
        PERFORM actualizar_reporte_diario(DATE(OLD.fecha));
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_compras_reporte
    AFTER INSERT OR UPDATE ON "Compras"
    FOR EACH ROW
    EXECUTE FUNCTION trigger_actualizar_reporte_compra();

-- ===================================================================
-- 6. VISTAS PARA REPORTES COMUNES
-- ===================================================================

-- Vista para reporte de productos más vendidos
CREATE OR REPLACE VIEW vista_productos_mas_vendidos AS
SELECT 
    p.id,
    p.nombre,
    p.precio,
    cp.nombre as categoria,
    COALESCE(SUM(vd.cantidad), 0) as total_vendido,
    COALESCE(SUM(vd.subtotal), 0) as ingresos_totales,
    COUNT(DISTINCT vd.id_venta) as numero_ventas
FROM "Productos" p
LEFT JOIN "Categoria_producto" cp ON p."id_Categoria_producto" = cp.id
LEFT JOIN "Ventas_detalle" vd ON p.id = vd.id_producto
LEFT JOIN "Ventas" v ON vd.id_venta = v.id
GROUP BY p.id, p.nombre, p.precio, cp.nombre
ORDER BY total_vendido DESC;

-- Vista para reporte de ventas por método de pago
CREATE OR REPLACE VIEW vista_ventas_por_metodo_pago AS
SELECT 
    COALESCE(metodo_pago, 'No especificado') as metodo_pago,
    COUNT(*) as numero_ventas,
    SUM(total) as total_ventas,
    AVG(total) as ticket_promedio
FROM "Ventas"
GROUP BY metodo_pago
ORDER BY total_ventas DESC;

-- Vista para reporte mensual
CREATE OR REPLACE VIEW vista_reporte_mensual AS
SELECT 
    EXTRACT(YEAR FROM fecha) as año,
    EXTRACT(MONTH FROM fecha) as mes,
    SUM(total_ventas) as total_ventas_mes,
    SUM(numero_ventas) as numero_ventas_mes,
    SUM(total_compras) as total_compras_mes,
    AVG(ticket_promedio) as ticket_promedio_mes,
    SUM(productos_vendidos) as productos_vendidos_mes
FROM "Reportes_diarios"
GROUP BY EXTRACT(YEAR FROM fecha), EXTRACT(MONTH FROM fecha)
ORDER BY año DESC, mes DESC;

-- ===================================================================
-- 7. CONSULTAS DE EJEMPLO PARA REPORTES
-- ===================================================================

-- COMENTARIOS CON CONSULTAS ÚTILES:

/*
-- Reporte de ventas por día en un rango de fechas
SELECT * FROM "Reportes_diarios" 
WHERE fecha BETWEEN '2024-01-01' AND '2024-01-31'
ORDER BY fecha;

-- Top 10 productos más vendidos del mes actual
SELECT * FROM vista_productos_mas_vendidos 
LIMIT 10;

-- Ventas por método de pago
SELECT * FROM vista_ventas_por_metodo_pago;

-- Reporte detallado de una venta específica
SELECT 
    v.id as venta_id,
    v.fecha,
    v.total,
    v.metodo_pago,
    p.nombre as producto,
    vd.cantidad,
    vd.precio_unitario,
    vd.subtotal
FROM "Ventas" v
JOIN "Ventas_detalle" vd ON v.id = vd.id_venta
JOIN "Productos" p ON vd.id_producto = p.id
WHERE v.id = ?;

-- Productos con stock bajo (menos de 10 unidades)
SELECT nombre, stock, precio 
FROM "Productos" 
WHERE stock < 10 
ORDER BY stock ASC;

-- Análisis de rentabilidad (ventas vs compras) por mes
SELECT 
    año,
    mes,
    total_ventas_mes,
    total_compras_mes,
    (total_ventas_mes - total_compras_mes) as ganancia_bruta,
    CASE 
        WHEN total_compras_mes > 0 THEN 
            ((total_ventas_mes - total_compras_mes) / total_compras_mes * 100)
        ELSE 0 
    END as margen_porcentaje
FROM vista_reporte_mensual;
*/

-- ===================================================================
-- INSTRUCCIONES DE USO:
-- ===================================================================
/*
1. La tabla más IMPORTANTE es "Ventas_detalle" - es ESENCIAL
2. "Reportes_diarios" es opcional pero acelera mucho las consultas
3. "Compras_detalle" solo si necesitas reportes detallados de compras
4. Las vistas simplifican las consultas comunes
5. Los triggers mantienen "Reportes_diarios" actualizada automáticamente

ORDEN DE IMPLEMENTACIÓN SUGERIDO:
1. Crear "Ventas_detalle" PRIMERO
2. Migrar datos existentes de ventas (si es posible)
3. Crear "Reportes_diarios" y sus funciones
4. Crear las vistas
5. Probar con datos de ejemplo
*/

-- ===================================================================
-- 8. FUNCIONES PARA REPORTES DE CORTES DE INVENTARIO
-- ===================================================================

-- Función para generar un corte de inventario (productos)
-- Usa la tabla existente "Corte_inventario" pero adaptada para productos
CREATE OR REPLACE FUNCTION generar_corte_inventario_productos(
    p_fecha_corte DATE DEFAULT CURRENT_DATE,
    p_observaciones TEXT DEFAULT NULL
)
RETURNS INTEGER AS $$
DECLARE
    v_corte_id INTEGER;
    v_productos_ids INTEGER[];
    v_stocks_iniciales INTEGER[];
    producto_record RECORD;
BEGIN
    -- Obtener todos los productos activos con sus stocks
    SELECT ARRAY_AGG(id), ARRAY_AGG(stock) 
    INTO v_productos_ids, v_stocks_iniciales
    FROM "Productos" 
    WHERE activo = true;

    -- Crear el corte principal
    INSERT INTO "Corte_inventario" (
        fecha_corte,
        inicio_corte,
        estado,
        ids_mps,
        stock_inicial
    ) VALUES (
        p_fecha_corte,
        CURRENT_TIME,
        'productos_iniciado',
        v_productos_ids,
        v_stocks_iniciales
    ) RETURNING id INTO v_corte_id;

    -- Crear reportes detallados para cada producto
    FOR producto_record IN 
        SELECT id, stock FROM "Productos" WHERE activo = true
    LOOP
        INSERT INTO "Reportes_cortes" (
            id_corte,
            id_materia_prima,
            stock_inicial,
            stock_final,
            diferencia,
            porcentaje_diferencia,
            fecha_corte,
            observaciones
        ) VALUES (
            v_corte_id,
            producto_record.id,
            producto_record.stock,
            producto_record.stock, -- stock_final será igual inicialmente
            0, -- diferencia inicial es 0
            0.0, -- porcentaje inicial es 0
            p_fecha_corte,
            p_observaciones
        );
    END LOOP;

    RETURN v_corte_id;
END;
$$ LANGUAGE plpgsql;

-- Función para obtener el detalle de productos en un corte
CREATE OR REPLACE FUNCTION obtener_detalle_corte_productos(p_corte_id INTEGER)
RETURNS TABLE (
    producto_id INTEGER,
    nombre VARCHAR,
    categoria VARCHAR,
    stock_inicial INTEGER,
    stock_final INTEGER,
    diferencia INTEGER,
    precio DECIMAL(10,2),
    valor_stock DECIMAL(10,2),
    estado_stock VARCHAR
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        p.id,
        p.nombre,
        COALESCE(cp.nombre, 'Sin categoría') as categoria,
        rc.stock_inicial::INTEGER,
        rc.stock_final::INTEGER,
        rc.diferencia::INTEGER,
        p.precio,
        (rc.stock_final * p.precio) as valor_stock,
        CASE 
            WHEN rc.stock_final = 0 THEN 'Sin stock'
            WHEN rc.stock_final < 10 THEN 'Stock bajo'
            WHEN rc.stock_final < 50 THEN 'Stock normal'
            ELSE 'Stock alto'
        END as estado_stock
    FROM "Reportes_cortes" rc
    JOIN "Productos" p ON rc.id_materia_prima = p.id
    LEFT JOIN "Categoria_producto" cp ON p."id_Categoria_producto" = cp.id
    WHERE rc.id_corte = p_corte_id
    ORDER BY cp.nombre, p.nombre;
END;
$$ LANGUAGE plpgsql;

-- Función para obtener estadísticas de cortes por período
CREATE OR REPLACE FUNCTION estadisticas_cortes_productos_periodo(
    p_fecha_inicio DATE,
    p_fecha_fin DATE
)
RETURNS TABLE (
    corte_id INTEGER,
    fecha_corte DATE,
    total_productos INTEGER,
    valor_total DECIMAL(10,2),
    productos_sin_stock INTEGER,
    productos_stock_bajo INTEGER,
    observaciones TEXT
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        ci.id,
        ci.fecha_corte,
        COUNT(rc.id)::INTEGER as total_productos,
        COALESCE(SUM(rc.stock_final * p.precio), 0)::DECIMAL(10,2) as valor_total,
        COUNT(CASE WHEN rc.stock_final = 0 THEN 1 END)::INTEGER as productos_sin_stock,
        COUNT(CASE WHEN rc.stock_final < 10 AND rc.stock_final > 0 THEN 1 END)::INTEGER as productos_stock_bajo,
        MAX(rc.observaciones) as observaciones
    FROM "Corte_inventario" ci
    LEFT JOIN "Reportes_cortes" rc ON ci.id = rc.id_corte
    LEFT JOIN "Productos" p ON rc.id_materia_prima = p.id
    WHERE ci.fecha_corte BETWEEN p_fecha_inicio AND p_fecha_fin
    AND ci.estado LIKE '%productos%'
    GROUP BY ci.id, ci.fecha_corte
    ORDER BY ci.fecha_corte DESC;
END;
$$ LANGUAGE plpgsql;

-- Función para obtener productos críticos (sin stock o stock bajo)
CREATE OR REPLACE FUNCTION productos_criticos_inventario()
RETURNS TABLE (
    id INTEGER,
    nombre VARCHAR,
    categoria VARCHAR,
    stock INTEGER,
    precio DECIMAL(10,2),
    estado VARCHAR,
    dias_sin_venta INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        p.id,
        p.nombre,
        COALESCE(cp.nombre, 'Sin categoría') as categoria,
        p.stock,
        p.precio,
        CASE 
            WHEN p.stock = 0 THEN 'CRÍTICO: Sin stock'
            WHEN p.stock < 5 THEN 'URGENTE: Stock muy bajo'
            WHEN p.stock < 10 THEN 'ALERTA: Stock bajo'
            ELSE 'Normal'
        END as estado,
        COALESCE(
            DATE_PART('day', NOW() - (
                SELECT MAX(v.fecha) 
                FROM "Ventas" v 
                JOIN "Ventas_detalle" vd ON v.id = vd.id_venta 
                WHERE vd.id_producto = p.id
            ))::INTEGER, 
            9999
        ) as dias_sin_venta
    FROM "Productos" p
    LEFT JOIN "Categoria_producto" cp ON p."id_Categoria_producto" = cp.id
    WHERE p.activo = true 
    AND (p.stock <= 10 OR p.stock = 0)
    ORDER BY 
        CASE 
            WHEN p.stock = 0 THEN 1
            WHEN p.stock < 5 THEN 2
            WHEN p.stock < 10 THEN 3
            ELSE 4
        END,
        p.stock ASC,
        p.nombre;
END;
$$ LANGUAGE plpgsql;

-- Función para comparar dos cortes de inventario
CREATE OR REPLACE FUNCTION comparar_cortes_productos(
    p_corte_id1 INTEGER,
    p_corte_id2 INTEGER
)
RETURNS TABLE (
    producto_id INTEGER,
    nombre VARCHAR,
    categoria VARCHAR,
    stock_corte1 INTEGER,
    stock_corte2 INTEGER,
    diferencia_stock INTEGER,
    precio DECIMAL(10,2),
    diferencia_valor DECIMAL(10,2)
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        p.id,
        p.nombre,
        COALESCE(cp.nombre, 'Sin categoría') as categoria,
        COALESCE(rc1.stock_final, 0)::INTEGER as stock_corte1,
        COALESCE(rc2.stock_final, 0)::INTEGER as stock_corte2,
        (COALESCE(rc2.stock_final, 0) - COALESCE(rc1.stock_final, 0))::INTEGER as diferencia_stock,
        p.precio,
        ((COALESCE(rc2.stock_final, 0) - COALESCE(rc1.stock_final, 0)) * p.precio)::DECIMAL(10,2) as diferencia_valor
    FROM "Productos" p
    LEFT JOIN "Categoria_producto" cp ON p."id_Categoria_producto" = cp.id
    LEFT JOIN "Reportes_cortes" rc1 ON p.id = rc1.id_materia_prima AND rc1.id_corte = p_corte_id1
    LEFT JOIN "Reportes_cortes" rc2 ON p.id = rc2.id_materia_prima AND rc2.id_corte = p_corte_id2
    WHERE p.activo = true
    AND (rc1.id IS NOT NULL OR rc2.id IS NOT NULL)
    ORDER BY ABS(COALESCE(rc2.stock_final, 0) - COALESCE(rc1.stock_final, 0)) DESC, p.nombre;
END;
$$ LANGUAGE plpgsql;

-- ===================================================================
-- 9. VISTAS PARA REPORTES DE CORTES
-- ===================================================================

-- Vista para histórico de cortes con tendencias (productos)
CREATE OR REPLACE VIEW vista_historico_cortes_productos AS
SELECT 
    ci.id,
    ci.fecha_corte,
    COUNT(rc.id) as total_productos,
    COALESCE(SUM(rc.stock_final * p.precio), 0) as valor_total_inventario,
    COUNT(CASE WHEN rc.stock_final = 0 THEN 1 END) as productos_sin_stock,
    COUNT(CASE WHEN rc.stock_final < 10 AND rc.stock_final > 0 THEN 1 END) as productos_stock_bajo,
    MAX(rc.observaciones) as observaciones,
    LAG(COALESCE(SUM(rc.stock_final * p.precio), 0)) OVER (ORDER BY ci.fecha_corte) as valor_anterior,
    (COALESCE(SUM(rc.stock_final * p.precio), 0) - LAG(COALESCE(SUM(rc.stock_final * p.precio), 0)) OVER (ORDER BY ci.fecha_corte)) as variacion_valor,
    CASE 
        WHEN LAG(COALESCE(SUM(rc.stock_final * p.precio), 0)) OVER (ORDER BY ci.fecha_corte) IS NULL THEN 'Primer corte'
        WHEN COALESCE(SUM(rc.stock_final * p.precio), 0) > LAG(COALESCE(SUM(rc.stock_final * p.precio), 0)) OVER (ORDER BY ci.fecha_corte) THEN 'Incremento'
        WHEN COALESCE(SUM(rc.stock_final * p.precio), 0) < LAG(COALESCE(SUM(rc.stock_final * p.precio), 0)) OVER (ORDER BY ci.fecha_corte) THEN 'Decremento'
        ELSE 'Sin cambio'
    END as tendencia
FROM "Corte_inventario" ci
LEFT JOIN "Reportes_cortes" rc ON ci.id = rc.id_corte
LEFT JOIN "Productos" p ON rc.id_materia_prima = p.id
WHERE ci.estado LIKE '%productos%'
GROUP BY ci.id, ci.fecha_corte
ORDER BY ci.fecha_corte DESC;

-- Vista para estado actual del inventario por categorías
CREATE OR REPLACE VIEW vista_inventario_por_categoria AS
SELECT 
    COALESCE(cp.nombre, 'Sin categoría') as categoria,
    COUNT(p.id) as total_productos,
    SUM(p.stock) as stock_total,
    SUM(p.stock * p.precio) as valor_total,
    AVG(p.precio) as precio_promedio,
    COUNT(CASE WHEN p.stock = 0 THEN 1 END) as productos_sin_stock,
    COUNT(CASE WHEN p.stock < 10 AND p.stock > 0 THEN 1 END) as productos_stock_bajo,
    MIN(p.stock) as stock_minimo,
    MAX(p.stock) as stock_maximo
FROM "Productos" p
LEFT JOIN "Categoria_producto" cp ON p."id_Categoria_producto" = cp.id
WHERE p.activo = true
GROUP BY cp.nombre
ORDER BY valor_total DESC;

-- ===================================================================
-- 10. CONSULTAS DE EJEMPLO PARA CORTES DE INVENTARIO
-- ===================================================================

/*
-- Generar un nuevo corte de inventario de productos
SELECT generar_corte_inventario_productos(CURRENT_DATE, 'Corte mensual de inventario');

-- Obtener el último corte realizado
SELECT * FROM "Corte_inventario" WHERE estado LIKE '%productos%' ORDER BY fecha_corte DESC LIMIT 1;

-- Ver productos críticos (sin stock o stock bajo)
SELECT * FROM productos_criticos_inventario();

-- Estadísticas de cortes del último mes
SELECT * FROM estadisticas_cortes_productos_periodo(
    CURRENT_DATE - INTERVAL '30 days', 
    CURRENT_DATE
);

-- Ver detalle de un corte específico
SELECT * FROM obtener_detalle_corte_productos(1);

-- Inventario por categorías
SELECT * FROM vista_inventario_por_categoria;

-- Histórico de cortes con tendencias
SELECT * FROM vista_historico_cortes_productos LIMIT 10;

-- Comparar dos cortes
SELECT * FROM comparar_cortes_productos(1, 2);

-- Productos que no se han vendido en los últimos 30 días
SELECT p.nombre, p.stock, p.precio,
       DATE_PART('day', NOW() - MAX(v.fecha)) as dias_sin_venta
FROM "Productos" p
LEFT JOIN "Ventas_detalle" vd ON p.id = vd.id_producto
LEFT JOIN "Ventas" v ON vd.id_venta = v.id
WHERE p.activo = true
GROUP BY p.id, p.nombre, p.stock, p.precio
HAVING MAX(v.fecha) < NOW() - INTERVAL '30 days' OR MAX(v.fecha) IS NULL
ORDER BY dias_sin_venta DESC;

-- Valor total del inventario por mes (usando cortes)
SELECT 
    DATE_TRUNC('month', ci.fecha_corte) as mes,
    AVG(sub.valor_total) as valor_promedio_mes,
    COUNT(DISTINCT ci.id) as numero_cortes
FROM "Corte_inventario" ci
JOIN (
    SELECT 
        rc.id_corte,
        SUM(rc.stock_final * p.precio) as valor_total
    FROM "Reportes_cortes" rc
    JOIN "Productos" p ON rc.id_materia_prima = p.id
    GROUP BY rc.id_corte
) sub ON ci.id = sub.id_corte
WHERE ci.estado LIKE '%productos%'
GROUP BY DATE_TRUNC('month', ci.fecha_corte)
ORDER BY mes DESC;
*/

-- ===================================================================
-- RESUMEN DE FUNCIONES DISPONIBLES:
-- ===================================================================
/*
REPORTES DE VENTAS:
- actualizar_reporte_diario(fecha)
- vista_productos_mas_vendidos
- vista_ventas_por_metodo_pago
- vista_reporte_mensual

REPORTES DE CORTES/INVENTARIO (usando tablas existentes):
- generar_corte_inventario_productos(fecha, observaciones)
- obtener_detalle_corte_productos(corte_id)
- estadisticas_cortes_productos_periodo(fecha_inicio, fecha_fin)
- productos_criticos_inventario()
- comparar_cortes_productos(corte_id1, corte_id2)
- vista_historico_cortes_productos
- vista_inventario_por_categoria

TRIGGERS AUTOMÁTICOS:
- trigger_actualizar_reporte_venta() - actualiza reportes diarios al hacer ventas
- trigger_actualizar_reporte_compra() - actualiza reportes diarios al hacer compras

¡IMPORTANTE!
1. Ejecutar este script DESPUÉS de crear las tablas base
2. La tabla "Ventas_detalle" es ESENCIAL para reportes detallados
3. "Reportes_diarios" se actualiza automáticamente con los triggers
4. Los cortes de productos usan las tablas existentes "Corte_inventario" y "Reportes_cortes"
5. Para productos, el campo id_materia_prima referencia a "Productos".id
*/
